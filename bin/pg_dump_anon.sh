#!/bin/bash
#
#    pg_dump_anon
#    A basic wrapper to export anonymized data with pg_dump and psql
#
#    This is work in progress. Use with care.
#
#

usage()
{
  echo "Usage: $(basename $0) [OPTION]... [DBNAME]"
  echo
  echo "Connection options:"
  echo
  echo "-d, --dbname=DBNAME      database to dump"
  echo "-f, --file=FILENAME      output file"
  echo "-h, --host=HOSTNAME      database server host or socket directory"
  echo "-p, --port=PORT          database server port number"
  echo "-U, --username=NAME      connect as specified database user"
  echo "-w, --no-password        never prompt for password"
  echo "-W, --password           force password prompt (should happen automatically)"
  echo "--help                   display this message"
}

## Return the version of the anon extension
get_anon_version() {
$PSQL << EOSQL
  SELECT extversion FROM pg_catalog.pg_extension WHERE extname='anon';
EOSQL
}

## Return the table name based on the relid
get_table_name() {
$PSQL << EOSQL
  SET search_path = '';
  SELECT $1::REGCLASS;
EOSQL
}

## Return the masking filters based on the relid
get_mask_filters() {
$PSQL << EOSQL
  SELECT anon.mask_filters($1);
EOSQL
}


## generate the "COPY ... FROM STDIN" statement for a given table
print_copy_statement () {
  table_name=$(get_table_name $1)
  filters=$(get_mask_filters $1)
  echo COPY $table_name FROM STDIN WITH CSV';'
  $PSQL_OUTPUT -c "\copy (SELECT $filters FROM $table_name) TO STDOUT WITH CSV"
  echo \\.
  echo
}

## Return the relid of each user table
list_user_tables() {
$PSQL $psql_connect_opt << EOSQL
  SELECT relid
  FROM pg_stat_user_tables
  WHERE schemaname NOT IN ( 'anon' , anon.mask_schema() )
  ORDER BY  relid::regclass -- sort by name to force the dump order
EOSQL
}

##
## M A I N
##

SHORT_OPTIONS=d:f:h:p:U:wW
LONG_OPTIONS=dbname:,file:,host:,port:,username:,no-password,password,help

## Checks options
options=$(getopt -o $SHORT_OPTIONS --long $LONG_OPTIONS -- "$@" 2>/dev/null)
if [ $? -ne 0 ]
then
  # rerun getopt to find which option is invalid
  errmsg=$(getopt -o $SHORT_OPTIONS -l $LONG_OPTIONS -- "$@" 2>&1 1>&-)
  # Strip getopt's prefix and augment with custom information.
  echo -e "${errmsg#getopt: }\nTry '$0 --help for more information." 1>&2
  exit
fi

##
## pg_dump and psql have a lot of common parameters ( -h, -d, etc.) but they
## also have similar parameters with different names (e.g. `pg_dump -f` and 
## `psql -o` ). This wrapper script allows a subset of pg_dump's parameters 
## and when needed, we transform the pg_dump options into the matching psql 
## options
##
psql_connect_opt= # connections options
psql_other_opt=   # other options (currently only -f is supported)

while [ $# -gt 0 ]; do
    case "$1" in
    -d|--dbname)
        psql_connect_opt+=" $1"
        shift
        psql_connect_opt+=" $1"
        ;;
    -f|--file)
        psql_other_opt+=" --output"
        shift
        psql_other_opt+=" $1"
        ;;
    -h|--host)
        psql_connect_opt+=" $1"
        shift
        psql_connect_opt+=" $1"
        ;;
    -p|--port)
        psql_connect_opt+=" $1"
        shift
        psql_connect_opt+=" $1"
        ;;
    -U|--username)
        psql_connect_opt+=" $1"
        shift
        psql_connect_opt+=" $1"
        ;;
    -w|--no-password)
        psql_connect_opt+=" $1"
        ;;
    -W|--password)
        psql_connect_opt+=" $1"
        ;;
    --help)
        usage
        exit 0
        ;;
    ?)
        echo "Error: Invalid option was specified -$1"
        exit 1
        ;;
    esac
    shift
done

PSQL="psql $psql_connect_opt --quiet --tuples-only --no-align"
PSQL_OUTPUT="$PSQL $psql_other_opt"

## Stop if the extension is not installed in the database
version=$(get_anon_version)
if [ -z "$version" ]
then
  echo 'ERROR: Anon extension is not installed in this database.'
  exit 1
fi

## Header
echo "--"
echo "-- Dump generated by PostgreSQL Anonymizer $version."
echo "--"
echo

## Dump the DDL
pg_dump --schema-only "$@"

## Dump the Masking Views instead of the real data
list_user_tables | while read -a record ; do
  print_copy_statement ${record[0]}
done

